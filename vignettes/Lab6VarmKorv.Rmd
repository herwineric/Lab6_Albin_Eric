---
title: "Lab6VarmKorv"
author: "Albin VÃ¤sterlund and Eric Herwin"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This package contains the three different methods for comuting the knapsack problem. The methods with functions are:

- `brute_force_knapsack`: Performs a brute force computation and you can have the option of parallel-compute this aswell.
- `dynamic_knapsack`: Performes a dynamic computation 

All of these methods are producing a output of a list with the `maximum` value of the opimal weight and `elements` that produces the maximum value. 

More reading about the knapsack problem can be found [here](https://en.wikipedia.org/wiki/Knapsack_problem)


## Question for 1.1.2

How long time does it take to run the brute force search on $n = 16$?

```{r, echo=FALSE, include=FALSE}

knapsack_objects <-
data.frame(
  w=sample(1:4000, size = 2000, replace = TRUE),
  v=runif(n = 2000, 0, 10000))
#Brute force


brute_force_knapsack <- function(x, W, parallel = FALSE){
  
  stopifnot(is.data.frame(x) | is.integer(W))
  
  if((sort(colnames(x))[1] == "v" & sort(colnames(x))[2] == "w" )==FALSE){
    stop("Could not find 'w' or 'v'")
  }
  
  #table(x$w > W)
  
  if(all(x$w > W)){
    message("The maximum weight is lower then any weight in the data frame")
  } else {
    
    
    if(parallel == FALSE){
      listas_txt <- lapply(1:nrow(x), FUN =  function(y) {
        combn(rownames(x), y, paste, collapse = " ")
        #apply(temp,2,paste, collapse = " ")
      })
      listas_w <- lapply(1:nrow(x), FUN =  function(y) { 
        combn(x$w, y, sum)
        #apply(temp,2,sum)
      })
      listas_v <- lapply(1:nrow(x), FUN =  function(y) { 
        combn(x$v, y,sum)
      })
      
      list_0_txt <- unlist(listas_txt)
      list_0_w <- unlist(listas_w)
      list_0_v <- round(unlist(listas_v),0)
      
      #find maximum
      maximum <- max(list_0_v[which(list_0_w < W)])
      
      #find the maximum combination
      element <- list_0_txt[which(list_0_w < W & list_0_v == maximum)]
      
      
      list_ret <- list(value = maximum, elements = as.numeric(strsplit(element, " ")[[1]]))
      
      
    } else {
      
      
      #x <<- x
      #CPU parallel
      require(parallel)
      requireNamespace("parallel")
      
      # Calculate the number of cores
      no_cores <- detectCores() - 1
      # Initiate cluster
      cl <- makeCluster(no_cores)
      
      
      #do the exact as non-parallel, but with parallel
      clusterExport(cl, c("x"),envir = environment())
      listas_txt <- parLapplyLB(cl, 1:nrow(x), fun =  function(y) {
        combn(rownames(x), y, paste0, collapse = " ")
        
      })
      listas_w <- parLapplyLB(cl, 1:nrow(x), fun =  function(y) {
        combn(x$w, y, sum)
        
      })
      listas_v <- parLapplyLB(cl,1:nrow(x), fun =  function(y) { 
        combn(x$v, y , sum)
        
      })
      
      
      stopCluster(cl)

      list_0_txt <- unlist(listas_txt)
      list_0_w <- unlist(listas_w)
      list_0_v <- round(unlist(listas_v),0)
      
      maximum <- max(list_0_v[which(list_0_w < W)])
      
      #find the maximum combination
      element <- list_0_txt[which(list_0_w < W & list_0_v == maximum)]
      
      list_ret <- list(value = maximum, elements = as.numeric(strsplit(element, " ")[[1]]))
      
    }
    
  }

  
  return(list_ret)
}


#greedy knapsack


greedy_knapsack <- function(x, W){
  
  stopifnot(is.data.frame(x) | is.integer(W))
  
  if((sort(colnames(x))[1] == "v" & sort(colnames(x))[2] == "w" )==FALSE){
    stop("Could not find 'w' or 'v'")
  }
  
  val_per_w <- x$v / x$w
  x$val_per_w <- val_per_w
  #order the data
  data_greed_sort <- x[order(x$val_per_w,decreasing = TRUE),]
  
  
  summie <- data_greed_sort$w[1]
  n <-0
  txt <- c()
  #do the summs
  while(summie < W){
    n <- n+1
    summie <- sum(data_greed_sort$w[1:n]) 
    val <- sum(data_greed_sort$v[1:n])
    txt[n] <- rownames(data_greed_sort)[n]
    
    
  }
  
  ret_list <- list(value = round(val - data_greed_sort$v[n] ,0),
                   elements = as.numeric(txt[1:(n-1)]))
  
  return(ret_list)
  
}



#dynamic knapsack


knapsack_dynamic <- function(x, W){
  
  stopifnot(is.data.frame(x) | is.integer(W))
  
  if((sort(colnames(x))[1] == "v" & sort(colnames(x))[2] == "w" )==FALSE){
    stop("Could not find 'w' or 'v'")
  }
  
  
  
  matr <- matrix(NA, ncol = W + 1, nrow = nrow(x) + 1)
  matr[1,] <- 0
  matr[,2] <- 0 
  
  el_order <- order(x$w)
  
  wt <- x[order(x$w), 1]
  val <- x[order(x$w), 2]
  elements <- c()
  
  for (i in 1:(nrow(x) + 1)) {
    for (j in 1:(W + 1)) {
      if (i == 1 || j == 1) {
        matr[i, j] <- 0
      } else if (wt[i - 1] < j - 1 | wt[i - 1] == j - 1) {
        if(matr[i - 1, j - wt[i - 1]] == 0){
          tal <- 0
        } else {
          tal <- matr[i - 1, j - wt[i - 1]]
        }
        matr[i, j] <- max(val[i - 1] + tal,  matr[i - 1, j])
      } else{
        matr[i, j] <- matr[i-1, j]
      }
      
    }
  }
  
  
  #Colaberated with Milda
  i <- nrow(x) + 1
  j <- W + 1
  n <- 1
  
  while (i >= 2 && j >= 1) {
    if (matr[i, j] > matr[i - 1, j]) {
      elements[n] <- el_order[i - 1]
      n <- n + 1
      j <- j - wt[i - 1]
    }
    i <- i - 1
  }
  
  list_ret <- list(value = round(max(matr)), elements = sort(elements))
  return(list_ret)
}




```

```{r,echo=FALSE,include=FALSE}
x <- Sys.time()
brute_force_knapsack(x = knapsack_objects[1:16,], W = 3500,parallel = FALSE)
y <- Sys.time()
time <- y-x
```

```{r}
#brute_force_knapsack(x = knapsack_objects[1:16,], W = 3500,parallel = FALSE)
time
```


We can see in the chunk how long time it takes for the brute force function with our parallel.


## Question for 1.1.3

How much time does it takes to run the algorithm, with the dynamic method, to calculate $n = 500$?


```{r,echo=FALSE,include=FALSE}
x <- Sys.time()
knapsack_dynamic(x = knapsack_objects[1:500,], W = 3500)
y <- Sys.time()
time <- y-x
```

```{r}
#knapsack_dynamic(x = knapsack_objects[1:500,], W = 3500)
time
```



## Question for 1.1.4


How much time does it takes to run the algorithm, with the greedy method, to calculate $n = 1000000$?


```{r,echo=FALSE,include=FALSE}
knapsack_objects <-
data.frame(
  w=sample(1:4000, size = 1000000, replace = TRUE),
  v=runif(n = 2000, 0, 10000))

x <- Sys.time()
lord <- lapply(seq(1001, 1000000, 1000) , function(z){
  greedy_knapsack(x = knapsack_objects[(z-1000)  :z,], W = 3500)
} )
y <- Sys.time()
time <- y-x
```

```{r}
#knapsack_dynamic(x = knapsack_objects[1:1000000,], W = 3500)
time
```


## Question for 1.1.6

So we will use the package `lineprof` to see if the code can be more efficient. To install the package, you have to use the code: `devtools::install_github("hadley/lineprof")`.

### brute force, no parallel

```{r}
#lineprof(hej <- brute_force_knapsack(x = knapsack_objects[1:8,], W = 3500,parallel = FALSE))
```


In this approach of the brute force method the lineprof funciton found that the `lapply` functions are the ones that slows it down. For this approah, there is probably very little to do to make this approach faster. Mabye to make calls to C++, Python or something equivalent.  

### brute force, with parallel

```{r}
#lineprof(hej <- brute_force_knapsack(x = knapsack_objects[1:8,], W = 3500,parallel = TRUE))
```

In this function, according to `lineprof` the step that takes the longest, and significant, amount of time is a cluster function `makeCluster` which is needed to set how many cores that are avaliable. Though i do not think you can make this any faster then to just swqitch from the OS Windows to, for example, Linux.

### knapsack_dynamic

```{r}
#lineprof(hej <- knapsack_dynamic(x = knapsack_objects[1:8,], W = 3500))
```

In this function the time that everything takes to run is very spread out, so basically just to improve the whole `for` and replace with, for example implementing function from the `apply()` family. Though with that approach will be complicated, due to the limitations of indexing with an `apply`.



### greedy_knapsack

```{r}
#lineprof(hej <- greedy_knapsack(x = knapsack_objects[1:800,], W = 3500))
```


In this function it is the sorting that take the most of the time. To make this faster an implementation of, for example the package `dplyr` could be used which is written in the language: C. For the sorting problem you could use the function `arrange()` in the package `dplyr`. 







