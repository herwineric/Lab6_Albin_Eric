apply(temp,2,paste, collapse = " ")
})
listas_w <- lapply(1:nrow(x), FUN =  function(y) {
temp <-combn(x$w, y)
apply(temp,2,sum)
})
listas_v <- lapply(1:nrow(x), FUN =  function(y) {
temp <-combn(x$v, y)
apply(temp,2,sum)
})
list_0_txt <- unlist(listas_txt)
list_0_w <- unlist(listas_w)
list_0_v <- round(unlist(listas_v),0)
#find maximum
maximum <- max(list_0_v[which(list_0_w < W)])
#find the maximum combination
element <- list_0_txt[which(list_0_w < W & list_0_v == maximum)]
list_ret <- list(value = maximum, elements = element)
} else {
x <<- x
#CPU parallel
library(parallel)
# Calculate the number of cores
no_cores <- detectCores() - 1
# Initiate cluster
cl <- makeCluster(no_cores)
#do the exact as non-parallel, but with parallel
clusterExport(cl, c("x"))
listas_txt <- parLapply(cl, 1:nrow(x), fun =  function(y) {
temp <- combn(rownames(x), y)
apply(temp,2,paste,collapse = " ")
})
listas_w <- parLapply(cl, 1:nrow(x), fun =  function(y) {
combn(x$w, y)
#apply(temp,2,sum)
})
listas_v <- parLapply(cl,1:nrow(x), fun =  function(y) {
combn(x$v, y)
#apply(temp, 2, sum)
})
fix_list_w <- parLapply(cl,listas_w,fun = colSums )
fix_list_v <- parLapply(cl,listas_v,fun = colSums )
stopCluster(cl)
list_0_txt <- unlist(listas_txt)
list_0_w <- unlist(fix_list_w)
list_0_v <- round(unlist(fix_list_v),0)
maximum <- max(list_0_v[which(list_0_w < W)])
#find the maximum combination
element <- list_0_txt[which(list_0_w < W & list_0_v == maximum)]
list_ret <- list(value = maximum, elements = as.numeric(strsplit(element, " ")[[1]]))
}
return(list_ret)
}
set.seed(42)
n <- 2000
knapsack_objects <-
data.frame(
w=sample(1:4000, size = 2000, replace = TRUE),
v=runif(n = n, 0, 10000)
)
knapsack_brute_force(x = knapsack_objects[1:8,], W = 3500,parallel = F)
knapsack_brute_force(x = knapsack_objects[1:8,], W = 3500,parallel = T)
knapsack_brute_force <- function(x, W, parallel = FALSE){
stopifnot(is.data.frame(x) | is.integer(W))
if((sort(colnames(x))[1] == "v" & sort(colnames(x))[2] == "w" )==FALSE){
stop("Could not find 'w' or 'v'")
}
if(parallel == FALSE){
listas_txt <- lapply(1:nrow(x), FUN =  function(y) {
temp <- combn(rownames(x), y)
apply(temp,2,paste, collapse = " ")
})
listas_w <- lapply(1:nrow(x), FUN =  function(y) {
temp <-combn(x$w, y)
apply(temp,2,sum)
})
listas_v <- lapply(1:nrow(x), FUN =  function(y) {
temp <-combn(x$v, y)
apply(temp,2,sum)
})
list_0_txt <- unlist(listas_txt)
list_0_w <- unlist(listas_w)
list_0_v <- round(unlist(listas_v),0)
#find maximum
maximum <- max(list_0_v[which(list_0_w < W)])
#find the maximum combination
element <- list_0_txt[which(list_0_w < W & list_0_v == maximum)]
list_ret <- list(value = maximum, elements = element)
} else {
x <<- x
#CPU parallel
library(parallel)
# Calculate the number of cores
no_cores <- detectCores() - 1
# Initiate cluster
cl <- makeCluster(no_cores)
#do the exact as non-parallel, but with parallel
clusterExport(cl, c("x"))
listas_txt <- parLapply(cl, 1:nrow(x), fun =  function(y) {
temp <- combn(rownames(x), y)
apply(temp,2,paste,collapse = " ")
})
listas_w <- parLapply(cl, 1:nrow(x), fun =  function(y) {
combn(x$w, y)
#apply(temp,2,sum)
})
listas_v <- parLapply(cl,1:nrow(x), fun =  function(y) {
combn(x$v, y)
#apply(temp, 2, sum)
})
fix_list_w <- parLapply(cl,listas_w,fun = colSums )
fix_list_v <- parLapply(cl,listas_v,fun = colSums )
stopCluster(cl)
list_0_txt <- unlist(listas_txt)
list_0_w <- unlist(fix_list_w)
list_0_v <- round(unlist(fix_list_v),0)
maximum <- max(list_0_v[which(list_0_w < W)])
#find the maximum combination
element <- list_0_txt[which(list_0_w < W & list_0_v == maximum)]
list_ret <- list(value = maximum, elements = as.numeric(strsplit(element, " ")[[1]]))
}
return(list_ret)
}
z <- Sys.time()
knapsack_brute_force(x = knapsack_objects[1:20,], W = 3500,parallel = T)
y <- Sys.time()
y-z
set.seed(42)
n <- 2000
knapsack_objects <-
data.frame(
w=sample(1:4000, size = 2000, replace = TRUE),
v=runif(n = n, 0, 10000)
)
z <- Sys.time()
knapsack_brute_force(x = knapsack_objects[1:20,], W = 3500,parallel = T)
y <- Sys.time()
y-z
z <- Sys.time()
knapsack_brute_force(x = knapsack_objects[1:20,], W = 3500,parallel = F)
y <- Sys.time()
y-z
z <- Sys.time()
knapsack_brute_force(x = knapsack_objects[1:20,], W = 3500,parallel = T)
y <- Sys.time()
y-z
listas_v <- lapply(1:nrow(x), FUN =  function(y) {
colSum(combn(x$v, y))
})
listas_v <- lapply(1:nrow(x), FUN =  function(y) {
colSums(combn(x$v, y))
})
listas_v
no_cores <- detectCores() - 1
cl <- makeCluster(no_cores)
clusterExport(cl, c("x"))
listas_w <- parLapply(cl, 1:nrow(x), fun =  function(y) {
colSums(combn(x$w, y))
#apply(temp,2,sum)
})
listas_txt <- parLapply(cl, 1:nrow(x), fun =  function(y) {
temp <- combn(rownames(x), y)
apply(temp,2,paste,collapse = " ")
})
listas_v <- parLapply(cl,1:nrow(x), fun =  function(y) {
colSums(combn(x$v, y))
#apply(temp, 2, sum)
})
listas_w
list_0_w <- unlist(listas_w)
list_0_w
listas_txt <- parLapply(cl, 1:nrow(x), fun =  function(y) {
temp <- combn(rownames(x), y)
apply(temp,2,paste0,collapse = " ")
})
listas_txt
knapsack_brute_force <- function(x, W, parallel = FALSE){
stopifnot(is.data.frame(x) | is.integer(W))
if((sort(colnames(x))[1] == "v" & sort(colnames(x))[2] == "w" )==FALSE){
stop("Could not find 'w' or 'v'")
}
if(parallel == FALSE){
listas_txt <- lapply(1:nrow(x), FUN =  function(y) {
temp <- combn(rownames(x), y)
apply(temp,2,paste, collapse = " ")
})
listas_w <- lapply(1:nrow(x), FUN =  function(y) {
temp <-combn(x$w, y)
apply(temp,2,sum)
})
listas_v <- lapply(1:nrow(x), FUN =  function(y) {
colSums(combn(x$v, y))
})
list_0_txt <- unlist(listas_txt)
list_0_w <- unlist(listas_w)
list_0_v <- round(unlist(listas_v),0)
#find maximum
maximum <- max(list_0_v[which(list_0_w < W)])
#find the maximum combination
element <- list_0_txt[which(list_0_w < W & list_0_v == maximum)]
list_ret <- list(value = maximum, elements = element)
} else {
x <<- x
#CPU parallel
library(parallel)
# Calculate the number of cores
no_cores <- detectCores() - 1
# Initiate cluster
cl <- makeCluster(no_cores)
#do the exact as non-parallel, but with parallel
clusterExport(cl, c("x"))
listas_txt <- parLapply(cl, 1:nrow(x), fun =  function(y) {
temp <- combn(rownames(x), y)
apply(temp,2,paste0,collapse = " ")
})
listas_w <- parLapply(cl, 1:nrow(x), fun =  function(y) {
colSums(combn(x$w, y))
#apply(temp,2,sum)
})
listas_v <- parLapply(cl,1:nrow(x), fun =  function(y) {
colSums(combn(x$v, y))
#apply(temp, 2, sum)
})
# fix_list_w <- parLapply(cl,listas_w,fun = colSums )
# fix_list_v <- parLapply(cl,listas_v,fun = colSums )
stopCluster(cl)
list_0_txt <- unlist(listas_txt)
list_0_w <- unlist(listas_w)
list_0_v <- round(unlist(listas_v),0)
maximum <- max(list_0_v[which(list_0_w < W)])
#find the maximum combination
element <- list_0_txt[which(list_0_w < W & list_0_v == maximum)]
list_ret <- list(value = maximum, elements = as.numeric(strsplit(element, " ")[[1]]))
}
return(list_ret)
}
z <- Sys.time()
knapsack_brute_force(x = knapsack_objects[1:15,], W = 3500,parallel = T)
y <- Sys.time()
y-z
knapsack_brute_force(x = knapsack_objects[1:8,], W = 3500,parallel = T)
z <- Sys.time()
knapsack_brute_force(x = knapsack_objects[1:20,], W = 3500,parallel = T)
y <- Sys.time()
y-z
set.seed(42)
n <- 2000
knapsack_objects <-
data.frame(
w=sample(1:4000, size = 2000, replace = TRUE),
v=runif(n = n, 0, 10000)
)
x = knapsack_objects[1:800,]
W = 3500
W = 3500
x = knapsack_objects[1:800,]
set.seed(42)
n <- 2000
knapsack_objects <-
data.frame(
w=sample(1:4000, size = 2000, replace = TRUE),
v=runif(n = n, 0, 10000)
)
x = knapsack_objects[1:800,]
x
val_per_w <- x$v / x$w
val_per_w
x$val_per_w <- val_per_w
x
x[order(x$val_per_w),]
data_greed <- x[order(x$val_per_w),]
data_greed <- x[order(x$val_per_w),]
head(data_greed)
data_greed <- x[order(x$val_per_w,decreasing = FALSE),]
head(data_greed)
data_greed <- x[order(x$val_per_w,decreasing = TRUE),]
head(data_greed)
head(data_greed,20)
data_greed_sort <- x[order(x$val_per_w,decreasing = TRUE),]
summie <- data_greed_sort$w[1]
summie
n <-0
summie <- data_greed_sort$w[1]
n <-0
while(summie < W){
n <- n+1
summie <- sum(data_greed_sort$w[1:n])
val <- sum(data_greed_sort$v[1:n])
}
val
txt <- c()
summie
rownames(data_greed_sort)
summie <- data_greed_sort$w[1]
n <-0
txt <- c()
while(summie < W){
if(summie > W) break
n <- n+1
summie <- sum(data_greed_sort$w[1:n])
val <- sum(data_greed_sort$v[1:n])
txt[n] <- rownames(data_greed_sort)[n]
}
val
summie
sum(data_greed_sort$w[1:n])
summie <- data_greed_sort$w[1]
n <-0
txt <- c()
while(summie < W){
n <- n+1
summie <- sum(data_greed_sort$w[1:n])
val <- sum(data_greed_sort$v[1:n]) - data_greed_sort$v[n]
txt[n] <- rownames(data_greed_sort)[n]
# if(summie > W) {
#   val <-
# }
}
val
round(val,0)
ret_list <- list(value = round(val,0), elements = as.numeric(txt))
ret_list
summie <- data_greed_sort$w[1]
n <-0
txt <- c()
while(summie < W){
n <- n+1
summie <- sum(data_greed_sort$w[1:n])
val <- sum(data_greed_sort$v[1:n]) - data_greed_sort$v[n]
txt[n] <- rownames(data_greed_sort)[1:(n-1)]
}
ret_list <- list(value = round(val,0), elements = as.numeric(txt))
summie <- data_greed_sort$w[1]
n <-0
txt <- c()
while(summie < W){
n <- n+1
summie <- sum(data_greed_sort$w[1:n])
val <- sum(data_greed_sort$v[1:n])
txt[n] <- rownames(data_greed_sort)[n]
}
ret_list <- list(value = round(val - data_greed_sort$v[n] ,0), elements = as.numeric(txt))
ret_list
ret_list <- list(value = round(val - data_greed_sort$v[n] ,0),
elements = as.numeric(txt[1:(n-1)]))
ret_list
greedy_knapsack <- function(x, W){
val_per_w <- x$v / x$w
x$val_per_w <- val_per_w
#order the data
data_greed_sort <- x[order(x$val_per_w,decreasing = TRUE),]
summie <- data_greed_sort$w[1]
n <-0
txt <- c()
#do the summs
while(summie < W){
n <- n+1
summie <- sum(data_greed_sort$w[1:n])
val <- sum(data_greed_sort$v[1:n])
txt[n] <- rownames(data_greed_sort)[n]
}
ret_list <- list(value = round(val - data_greed_sort$v[n] ,0),
elements = as.numeric(txt[1:(n-1)]))
return(ret_list)
}
set.seed(42)
n <- 2000
knapsack_objects <-
data.frame(
w=sample(1:4000, size = 2000, replace = TRUE),
v=runif(n = n, 0, 10000)
)
greedy_knapsack(x = knapsack_objects[1:800,], W = 3500)
greedy_knapsack(x = knapsack_objects[1:1200,], W = 2000)
requireNamespace(parallel)
require(parallel)
requireNamespace("parallel")
no_cores <- detectCores() - 1
cl <- makeCluster(no_cores)
cl
knapsack_brute_force <- function(x, W, parallel = FALSE){
stopifnot(is.data.frame(x) | is.integer(W))
if((sort(colnames(x))[1] == "v" & sort(colnames(x))[2] == "w" )==FALSE){
stop("Could not find 'w' or 'v'")
}
if(parallel == FALSE){
listas_txt <- lapply(1:nrow(x), FUN =  function(y) {
temp <- combn(rownames(x), y)
apply(temp,2,paste, collapse = " ")
})
listas_w <- lapply(1:nrow(x), FUN =  function(y) {
temp <-combn(x$w, y)
apply(temp,2,sum)
})
listas_v <- lapply(1:nrow(x), FUN =  function(y) {
colSums(combn(x$v, y))
})
list_0_txt <- unlist(listas_txt)
list_0_w <- unlist(listas_w)
list_0_v <- round(unlist(listas_v),0)
#find maximum
maximum <- max(list_0_v[which(list_0_w < W)])
#find the maximum combination
element <- list_0_txt[which(list_0_w < W & list_0_v == maximum)]
list_ret <- list(value = maximum, elements = element)
} else {
x <<- x
#CPU parallel
require(parallel)
requireNamespace("parallel")
# Calculate the number of cores
no_cores <- detectCores() - 1
# Initiate cluster
cl <- makeCluster(no_cores)
#do the exact as non-parallel, but with parallel
clusterExport(cl, c("x"))
listas_txt <- parLapply(cl, 1:nrow(x), fun =  function(y) {
temp <- combn(rownames(x), y)
apply(temp,2,paste0,collapse = " ")
})
listas_w <- parLapply(cl, 1:nrow(x), fun =  function(y) {
colSums(combn(x$w, y))
#apply(temp,2,sum)
})
listas_v <- parLapply(cl,1:nrow(x), fun =  function(y) {
colSums(combn(x$v, y))
#apply(temp, 2, sum)
})
# fix_list_w <- parLapply(cl,listas_w,fun = colSums )
# fix_list_v <- parLapply(cl,listas_v,fun = colSums )
stopCluster(cl)
list_0_txt <- unlist(listas_txt)
list_0_w <- unlist(listas_w)
list_0_v <- round(unlist(listas_v),0)
maximum <- max(list_0_v[which(list_0_w < W)])
#find the maximum combination
element <- list_0_txt[which(list_0_w < W & list_0_v == maximum)]
list_ret <- list(value = maximum, elements = as.numeric(strsplit(element, " ")[[1]]))
}
return(list_ret)
}
set.seed(42)
n <- 2000
knapsack_objects <-
data.frame(
w=sample(1:4000, size = 2000, replace = TRUE),
v=runif(n = n, 0, 10000)
)
)
knapsack_brute_force(x = knapsack_objects[1:8,], W = 3500,parallel = T)
knapsack_brute_force(x = knapsack_objects[1:8,], W = 3500,parallel = TRUE)
library(Lab6VarmKorv)
set.seed(42)
n <- 2000
knapsack_objects <-
data.frame(
w=sample(1:4000, size = 2000, replace = TRUE),
v=runif(n = n, 0, 10000)
)
x = knapsack_objects[1:8,]
W = 3500
x
combn(1:nrow(x), 1)
combn(x$w, 1)
combn(x$w, 2)
combn(x$w, 2,FUN = colSums)
combn(x$w, 2,FUN = sum)
hej <- combn(x$w, 2,FUN = sum)
sum(hej)
length(hej)
hej <- combn(x$w, 1,function(x) {
temp <- sum(x)
temp
})
hej
hej <- combn(x$w, 2,function(x) {
temp <- sum(x)
temp
})
hej <- combn(x$w, 2,function(x) {
temp <- sum(x)
temp[temp < W]
})
hej <- combn(x$w, 2,function(x) {
temp <- sum(x)
if(temp > W){
next
}
temp
})
hej <- combn(x$w, 2,function(x) {
temp <- sum(x)
if(temp > W){
temp <- NA
}
temp
})
hej
order(na.omit(temp))
order(na.omit(hej))
na.omit(hej)
order(na.omit(hej)[1])
order(na.omit(hej)[[1]])
order(hej)
length(as.vector(hej))
as.
order(as.vector(hej))
sort(as.vector(hej))
sort(hej)
length(as.vector(hej), FALSE)
sort(hej, FALSE)
sort(hej, TRUE)
